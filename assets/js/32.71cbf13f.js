(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{311:function(a,e,v){"use strict";v.r(e);var _=v(13),c=Object(_.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h3",{attrs:{id:"初识webpack"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#初识webpack"}},[a._v("#")]),a._v(" 初识webpack")]),a._v(" "),e("hr"),a._v(" "),e("h4",{attrs:{id:"一、webpack"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、webpack"}},[a._v("#")]),a._v(" 一、webpack")]),a._v(" "),e("ul",[e("li",[a._v("webpack是一个静态的模块化打包工具，为现代的JavaScript应用程序")]),a._v(" "),e("li",[a._v("分为以下几大模块：\n"),e("ul",[e("li",[a._v("打包bundler：webpack可以将帮助我们进行打包，所以它是一个打包工具")]),a._v(" "),e("li",[a._v("静态的static：我最终可以将代码打包成最终的静态资源（部署到静态资源服务器）")]),a._v(" "),e("li",[a._v("模块化module：webpack默认支持各种模块化开发，ES Module、CommonJS、AMD等")]),a._v(" "),e("li",[a._v("现代的modern： 现代前端开发面临的各种各样的问题，催生了webpack的出现和发展")])])])]),a._v(" "),e("h4",{attrs:{id:"二、工作中的webpack"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、工作中的webpack"}},[a._v("#")]),a._v(" 二、工作中的webpack")]),a._v(" "),e("ul",[e("li",[a._v("日常工作来说，比如在开发vue、react、 angular等项目的过程中我们需要一些特 殊的配置:比如给某些目录结构起别名， 让我们的项目支持sass、less等预处理 器，希望在项目中手动的添加 TypeScript的支持，都需要对webpack 进行一些特殊的配置工作。")]),a._v(" "),e("li",[a._v("当然，除了日常工作之外，如果我们希望 将在原有的脚手架上来定制一些自己的特 殊配置提供性能:比如安装性能分析工具、 使用gzip压缩代码、引用cdn的资源，公共 代码抽取等等操作，甚至包括需要编写属 于自己的loader和plugin。")]),a._v(" "),e("li",[a._v("对于想要在前端领域进阶成为高级前端开 发工程师，甚至是架构师的前端开发者来 说，webpack等构建工具是必须学习的， 包括其中的一些高级特性和原理，都是要 熟练掌握的。企业在招聘高级前端工程师 或者架构师时，必然会对webpack和其他 的构建工具有比较高的要求。")])]),a._v(" "),e("h4",{attrs:{id:"三、webpack和vite"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、webpack和vite"}},[a._v("#")]),a._v(" 三、webpack和vite")]),a._v(" "),e("p",[a._v("触类旁通")]),a._v(" "),e("h4",{attrs:{id:"四、webpack的核心内容"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、webpack的核心内容"}},[a._v("#")]),a._v(" 四、webpack的核心内容")]),a._v(" "),e("ul",[e("li",[a._v("webpack核心配置深入解析")]),a._v(" "),e("li",[a._v("webpack常用Loaders和Plugins深入学习")]),a._v(" "),e("li",[a._v("自定义webpack中自己的Laoder和Plugin")]),a._v(" "),e("li",[a._v("Babel各种用法以及polyfill、TypeScript的支持")]),a._v(" "),e("li",[a._v("ESlint的配置规则以及在VSCode、webpack中的使用")]),a._v(" "),e("li",[a._v("各种性能优化方案：打包抽取分包、Tree Shaking、动态链接库、CDN、gzip压缩等")]),a._v(" "),e("li",[a._v("webpack模块化原理解析、打包原理实现")]),a._v(" "),e("li",[a._v("掌握其他流行构建工具：gulp、rollup、vite")])]),a._v(" "),e("h4",{attrs:{id:"五、vue-cli-servive运行过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五、vue-cli-servive运行过程"}},[a._v("#")]),a._v(" 五、vue-cli-servive运行过程")]),a._v(" "),e("h4",{attrs:{id:"六、webpack的官方文档"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六、webpack的官方文档"}},[a._v("#")]),a._v(" 六、webpack的官方文档")]),a._v(" "),e("p",[a._v("官方文档： "),e("a",{attrs:{href:"https://webpack.docschina.org/",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://webpack.docschina.org/"),e("OutboundLink")],1)]),a._v(" "),e("ul",[e("li",[a._v("API：API，提供相关接口，可以自定义编译的过程（比如自定义loader和plugin可以参考该位置的API）")]),a._v(" "),e("li",[a._v("BLOG：博客，等同于上一个tab的BLOG，里面有一些博客文章")]),a._v(" "),e("li",[a._v("CONCEPTS：概念，主要介绍一些webpack的核心概念，比如入口、出口、Loaders、Plugins等，但是这里并没有一些对它们解析的详细API")]),a._v(" "),e("li",[a._v("CONFIGURATION：配置，webpack详细的配置选项，都可以在这里查询到，更多的时候作为查询手册")]),a._v(" "),e("li",[a._v("GUIDES：指南，更像是webpack提供给我们的教程，我们可以按照这个教程一步步学习webpack的使用过程")]),a._v(" "),e("li",[a._v("LOADERS：loaders，webpack的核心之一，常见的laoder都可以在这里查询到用法，比如css-loader、babel-loader、less-loader等")]),a._v(" "),e("li",[a._v("PLUGINS：plugins，webpack的核心之一，常见的plugin都可以在这里查询到用法，比如BannerPlugin、CleanWebpackPlugin、MiniCssExtraPlugin等")]),a._v(" "),e("li",[a._v("MIGRATE：迁移，可以通过这里的教程将webpack4迁移到webpack5等")])]),a._v(" "),e("h4",{attrs:{id:"七、webpack的依赖"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#七、webpack的依赖"}},[a._v("#")]),a._v(" 七、webpack的依赖")]),a._v(" "),e("p",[a._v("node")]),a._v(" "),e("h4",{attrs:{id:"八、webpack的安装"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#八、webpack的安装"}},[a._v("#")]),a._v(" 八、webpack的安装")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("webpack的安装目前分为两个：webpack、webpack-cli（cli可用其他cli替代）")])]),a._v(" "),e("li",[e("p",[a._v("它们之间的关系")]),a._v(" "),e("ul",[e("li",[a._v("执行webpack命令，会执行node_modules下的.bin目录下的webpack")]),a._v(" "),e("li",[a._v("webpack执行时是依赖webpack-cli的，如果没有安装就会报错")]),a._v(" "),e("li",[a._v("而webpack-cli中代码执行时，才是真正利用webpack进行编译和打包的过程")]),a._v(" "),e("li",[a._v("所以在安装webapck时，我们需要同时安装webpack-cli（第三方脚手架事实上是没有使用webpack-cli的，而是类似于自己的vue-service-cli的东西）")])]),a._v(" "),e("p",[a._v("截图？")])])]),a._v(" "),e("h4",{attrs:{id:"九、传统开发存在的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#九、传统开发存在的问题"}},[a._v("#")]),a._v(" 九、传统开发存在的问题")]),a._v(" "),e("ul",[e("li",[a._v("某些语法浏览器是不认识的（尤其在低版本的浏览器上）\n"),e("ol",[e("li",[a._v("使用了ES6语法，比如const、箭头函数等语法")]),a._v(" "),e("li",[a._v("使用了ES6的模块化语法")]),a._v(" "),e("li",[a._v("使用CommonJS的模块化语法")]),a._v(" "),e("li",[a._v("在通过script标签引入时，必须添加上 type=“module” 属性")])])]),a._v(" "),e("li",[a._v("显然，上面存在的问题，让我们在发布静态资源时，是不能直接发布的，因为运行在用户浏览器必然会存在各种各样的兼容性问题。\n"),e("ul",[e("li",[a._v("我们需要通过某个工具对其进行打包，让其转换成浏览器可以直接识别的语法;")])])])]),a._v(" "),e("h4",{attrs:{id:"十、webpack默认打包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#十、webpack默认打包"}},[a._v("#")]),a._v(" 十、webpack默认打包")]),a._v(" "),e("ul",[e("li",[a._v("我们可以通过webpack进行打包，之后运行打包之后的代码\n"),e("ul",[e("li",[a._v("在目录下直接执行 webpack 命令")])])]),a._v(" "),e("li",[a._v("生成一个dist文件夹，里面存放一个main.js的文件，就是我们打包之后的文件:\n"),e("ul",[e("li",[a._v("这个文件中的代码被压缩和丑化了;")]),a._v(" "),e("li",[a._v("我们暂时不关心他是如何做到的，后续我讲webpack实现模块化原理时会再次讲到;")]),a._v(" "),e("li",[a._v("另外我们发现代码中依然存在ES6的语法，比如箭头函数、const等，这是因为默认情况下webpack并不清楚 我们打包后的文件是否需要转成ES5之前的语法，后续我们需要通过babel来进行转换和设置;")])])]),a._v(" "),e("li",[a._v("我们发现是可以正常进行打包的，但是有一个问题，webpack是如何确定我们的入口的呢?\n"),e("ul",[e("li",[a._v("事实上，当我们运行webpack时，webpack会查找当前目录下的 src/index.js作为入口;")]),a._v(" "),e("li",[a._v("所以，如果当前项目中没有存在src/index.js文件，那么会报错;")])])])]),a._v(" "),e("h4",{attrs:{id:"十一、webpack配置文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#十一、webpack配置文件"}},[a._v("#")]),a._v(" 十一、webpack配置文件")]),a._v(" "),e("ul",[e("li",[a._v("webpack.config.js")]),a._v(" "),e("li",[a._v("指定配置文件\n"),e("ul",[e("li",[a._v("但是如果我们配置文件的名字并不是 webpack.config.js 而是其他的名字呢\n"),e("ul",[e("li",[a._v("比如将 webpack.config.js 修改成了 wk.config.js")]),a._v(" "),e("li",[a._v("这个时候我们可以通过 --config 来指定对应的配置文件\n"),e("code",[a._v("webpack --config wk.config.js")])])])])])]),a._v(" "),e("li",[a._v("增加脚本 "),e("code",[a._v("npm run build")])])]),a._v(" "),e("h4",{attrs:{id:"十二、webpack依赖图"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#十二、webpack依赖图"}},[a._v("#")]),a._v(" 十二、webpack依赖图")]),a._v(" "),e("ul",[e("li",[a._v("webpack到底是如何对我们的项目进行打包的呢？")])]),a._v(" "),e("ul",[e("li",[a._v("事实上webpack在处理应用程序时，它会根据命令或者配置文件来找到入口文件")]),a._v(" "),e("li",[a._v("从入口开始，会生成一个依赖图，这个依赖关系图会包含应用程序中所需要的所有模块（比如.js文件、css文件、图片、字体）")]),a._v(" "),e("li",[a._v("然后根据遍历图结构，打包一个个模块（根据文件的不同的loader来解析）")])])])}),[],!1,null,null,null);e.default=c.exports}}]);